# Vendor

crmeb

# Product

CRMEB-KY

# version

v5.6.1

# Download 

https://github.com/crmeb/CRMEB

# Vulnerability

SSRF

# Description

The Admin-triggered SSRF exists because the testOutUrl method in OutAccountServices.php directly passes a user-controlled URL ($data['push_token_url']) to HttpService::getRequest(). The HttpService::getRequest() and its internal request() methods use cURL to make an HTTP request to this URL without any validation or filtering of the URL's host or scheme (other than the default cURL protocol support). This allows an authenticated administrator to force the server to make arbitrary HTTP/HTTPS requests to internal or external network resources.

# Analysis

Vulnerability file: 
app/services/out/OutAccountServices.php (testOutUrl() method) and crmeb/services/HttpService.php (request() method) 

Vulnerability method: testOutUrl() 

Vulnerability analysis: testOutUrl() method receives the user-controlled push_token_url parameter and passes it to HttpService::getRequest(). HttpService::getRequest() uses cURL for HTTP/HTTPS requests, but does not host validate the requested URL. 
This allows authenticated administrators to exploit this vulnerability to scan internal network ports, detect internal services, or make HTTP requests to external services.

1. app/services/out/OutAccountServices.php - testOutUrl() method:
```
253 |     public function textOutUrl($data)
254 |     {
255 |         if (!$data['push_account'] || !$data['push_password'] || !$data['push_token_url']) throw new AdminException(100100);
256 |         $param = ['push_account' => $data['push_account'], 'push_password' => $data['push_password']];
257 |         $res = HttpService::getRequest($data['push_token_url'], $param); // <-- Vulnerable call
258 |         $res = $res ? json_decode($res, true) : ['status' => 400];
259 |         if (!isset($res['status']) && $res['status'] != 200) {
260 |             throw new AdminException(100015);
261 |         } else {
262 |             return $res['data'];
263 |         }
264 |     }
```


Line 255: Checks for the presence of push_account, push_password, and push_token_url. These are all user-controlled inputs from the API request.
Line 257: This is the direct point of vulnerability. The user-controlled $data['push_token_url'] is passed directly as the $url argument to HttpService::getRequest(). There is no validation, sanitization, or filtering of the $data['push_token_url'] before it is used to make an outbound HTTP request.
2. crmeb/services/HttpService.php - getRequest() and request() methods:
```
62 |     public static function getRequest($url, $data = array(), $header = false, $timeout = 10)
63 |     {
64 |         if (!empty($data)) {
65 |             $url .= (stripos($url, '?') === false ? '?' : '&');
66 |             $url .= (is_array($data) ? http_build_query($data) : $data);
67 |         }
68 | 
69 |         return self::request($url, 'get', array(), $header, $timeout); // <-- Passes $url to internal request()
70 |     }
```
```
81 |     public static function request($url, $method = 'get', $data = array(), $header = false, $timeout = 15)
82 |     {
83 |         // ...
84 |         self::$status = null;
85 |         self::$curlError = null;
86 |         self::$headerStr = null;
87 | 
88 |         $curl = curl_init($url); // <-- cURL is initialized with the unfiltered, user-controlled $url
89 |         // ...
111 |         if (1 == strpos("$" . $url, "https://")) {
112 |             curl_setopt($curl, CURLOPT_SSL_VERIFYPEER, false);
113 |             curl_setopt($curl, CURLOPT_SSL_VERIFYHOST, false);
114 |         }
115 |         self::$curlError = curl_error($curl);
116 | 
117 |         list($content, $status) = [curl_exec($curl), curl_getinfo($curl), curl_close($curl)];
118 |         self::$status = $status;
119 |         self::$headerStr = trim(substr($content, 0, $status['header_size']));
120 |         $content = trim(substr($content, $status['header_size']));
121 |         return (intval($status["http_code"]) === 200) ? $content : false;
122 |     }
```

Line 69: The $url (which is $data['push_token_url'] from the user) is passed to the request() method.
Line 88: curl_init($url) is called with the unfiltered, user-controlled $url. This is the core of the SSRF vulnerability. cURL will then attempt to connect to the host specified in $url, regardless of whether it's an internal or external address.
Missing Host Validation: There are no curl_setopt() calls or other PHP code that explicitly validates or restricts the host/IP address in $url to prevent connections to internal network resources.

Recurrence of vulnerabilities:

<img width="1197" height="363" alt="image" src="https://github.com/user-attachments/assets/3c35e093-4d3e-42b7-bbc0-46f6710d1cbb" />


# POC
```
POST /api/address/edit HTTP/1.1
Host: 127.0.0.1:81
Authori-zation: XXX
content-type: application/json
Content-Length: 199

{"real_name":"111","phone":"13111111111","detail":"111111","id":"2","address":{"province":"\u5317\u4eac\u5e02","city":"\u5317\u4eac\u5e02","district":"\u4e1c\u57ce\u533a","city_id":2},"is_default":1}

```
