# Vendor

crmeb

# Product

CRMEB-KY

# version

v5.6.1

# Download 

https://github.com/crmeb/CRMEB

# Vulnerability

Horizontal Overreach (IDOR) - Modify/delete user address

# Description

When editAddress is called to update an address with a given $id, the code always believes that the address belongs to the currently authenticated user, regardless of its true owner. An attacker can simply set the id field in their request to the ID of any address in the system, and they will be able to modify or delete it.

# Analysis

In app/services/user/UserAddressServices.php:

editAddress() method (lines 168-240):

This method handles both adding (id is 0) and editing (id is not 0) addresses.

Editing an existing address (lines 210-225):
```
210 |         if ($address_check && $address_check['is_del'] == 0 && $address_check['uid'] = $uid) {
211 |             $id = (int)$addressInfo['id'];
212 |             unset($addressInfo['id']);
213 |             if (!$this->dao->update($id, $addressInfo, 'id')) {
214 |                 throw new ApiException(100007);
215 |             }
216 |             if ($addressInfo['is_default']) {
217 |                 $this->setDefault($uid, $id);
218 |             }
219 |             return ['type' => 'edit', 'msg' => '编辑地址成功', 'data' => []];
220 |         }
```

Vulnerability Found (IDOR): The crucial line is 210: if ($address_check && $address_check['is_del'] == 0 && $address_check['uid'] = $uid).
There's a single equals sign (=) instead of a double equals sign (==) or triple equals sign (===) in the condition ($address_check['uid'] = $uid). This is a classic programming error that leads to a Horizontal Privilege Escalation / IDOR vulnerability.

Explanation of the bug:

$address_check['uid'] = $uid is an assignment operation, not a comparison.
It assigns the authenticated user's $uid to $address_check['uid'].
The result of an assignment operation is the assigned value, which is $uid. If $uid is a non-zero integer (which it almost always will be for a logged-in user), the condition ($address_check['uid'] = $uid) will always evaluate to true.

Recurrence of vulnerabilities:

Account A address id is 1, account B address id is 2.

When we edit the A account address, change the id to 2, and we can edit/delete the address information of account A.

<img width="1028" height="486" alt="image" src="https://github.com/user-attachments/assets/17a86fed-9cbd-460a-a0b8-28c8cd22b0de" />

Account A has an additional value of id 2. Address B corresponding to address id 2. Disappears

Account A:

<img width="603" height="1271" alt="image" src="https://github.com/user-attachments/assets/47bd2c22-ee5c-4887-8452-699cb3e22c34" />

Account B:

<img width="398" height="1191" alt="image" src="https://github.com/user-attachments/assets/05a74b3c-039e-4646-92cf-c6c0abbc7b94" />


# POC
```
PUT /adminapi/setting/admin/1 HTTP/1.1
Host: 127.0.0.1:81
Content-Length: 99
Content-Type: application/json;charset=UTF-8
Authori-zation: XXX
Connection: keep-alive

{"account":"admin","pwd":"1234567","conf_pwd":"1234567","real_name":"admin","roles":[1],"status":1}

```
